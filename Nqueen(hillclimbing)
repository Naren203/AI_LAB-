import random

N = 8  # Number of queens

# Generate random initial state (one queen per column)
def random_board(N):
    return [random.randint(0, N-1) for _ in range(N)]

# Heuristic function: count attacking pairs
def heuristic(board):
    h = 0
    for i in range(N):
        for j in range(i+1, N):
            if board[i] == board[j] or abs(board[i]-board[j]) == j-i:
                h += 1
    return h

# Hill Climbing algorithm with random restart
def hill_climbing():
    steps_total = 0
    while True:
        board = random_board(N)
        steps = 0
        while True:
            steps += 1
            h = heuristic(board)
            if h == 0:
                return board, steps_total + steps
            # Generate all neighbors and find best
            neighbors = []
            for col in range(N):
                for row in range(N):
                    if board[col] != row:
                        new_board = board[:]
                        new_board[col] = row
                        neighbors.append((heuristic(new_board), new_board))
            # Choose neighbor with lowest heuristic
            h_vals = [n[0] for n in neighbors]
            min_h = min(h_vals)
            if min_h >= h:  # stuck at local maximum
                break  # restart
            else:
                board = neighbors[h_vals.index(min_h)][1]
        steps_total += steps

# Visualize the board
def print_board(board):
    for row in range(N):
        line = ""
        for col in range(N):
            if board[col] == row:
                line += " Q "
            else:
                line += " . "
        print(line)

# Run the algorithm
solution, steps = hill_climbing()
print("Solution Board (column-wise):", solution)
print("Total steps taken:", steps)
print("\nBoard Visualization:")
print_board(solution)
